* [이것이 C#이다](https://www.hanbit.co.kr/store/books/look.php?p_code=B6673972966) 책을 참고하여 정리하였습니다.
* 자세한 내용은 책을 구매하여 확인해주세요

Garbage Collection을 인지한 효율적인 코드 작성법
===

# 1. 객체를 너무 많이 할당하지 않기
* CLR이 객체 할당 속도가 빨라도 너무 많은 수의 객체는 각 세대의 포화를 **빠르게** 하고 가비지 컬렉션을 자주 부르게 됨


***
# 2. 너무 큰 객체 할당 피하기
* CLR은 85KB 이상의 대형 객체를 할당하기 위한 **"대형 객체 힙(Large Object Heap)"** 을 따로 유지 ( 평소 사용하는 힙은 **소형 객체 힙(Small Object Heap)** 이라 함 )
* 대형 객체 힙은 **객체를 담을 공간이 있는지 먼저 파악한 후 할당**함
* 대형 객체 힙은 메모리 정리 후 빈 공간에 차곡차곡 쌓아 넣었던 소형 객체 힙과 다르게 할당된 그 위치에 두게 됨
   * 복사 비용이 너무 크기 때문
   * 메모리에 군데군데 빈 공간이 생김으로 **메모리 공간 효율**이 좋지 않음
   *  CLR은 "대형 객체 힙"을 2세대 힙으로 간주하기에 가비지 객체가 수거되려면 **2세대에 대한 가비지 컬렉션이 수행** ( 프로그램이 멈춤 )

***
# 3. 너무 복잡한 참조 관계 피하기
* 코드 가독성을 위해서라도 하지 않아야 함
* 가비지 컬렉션 후에 **살아남은 객체**들이 문제를 일으킴
* 가비지 컬렉션 후 세대를 옮기기 위해 메모리 복사가 이루어지는데 참조 관계가 복잡한 경우엔 **단순히 메모리 복사로 끝나지 않음**
   * 객체를 구성하고 있는 각 필드 객체 간 **참조 관계를 일일이 조사**해 참조하고 있는 **메모리 주소를 전부 수정**
* **쓰기 장벽(Write barrier)** 장치를 생성하는데 드는 오버 헤드가 큼


#### 쓰기 장벽이란?
< 예시 >
* 2세대에 살고 있는 B 객체가 있고, A형식의 객체 a를 생성
* a는 0세대에 있기 때문에 가비지 컬렉션에 의해 수거될 위험에 노출
* 이때, CLR은 "쓰기 장벽"을 통해 a가 루트를 갖고 있는 것으로 간주해 0세대 **가비지 컬렉션을 모면하게 해줌**

***
# 4. 루트를 너무 많이 만들지 않기
* 가비지 컬렉터는 **루트 목록**을 돌면서 가비지를 찾아낸다
* 그러므로, 루트 목록이 많아질수록 검사하는 양이 많아져 가비지 컬렉션의 **시간이 오래 걸림**
