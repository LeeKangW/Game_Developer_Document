Generational  Garbage Collection
===

### CLR이 메모리 구역 나누는 방법
* 빨리 해제될 객체와 오래 남을 객체를 따로 담아 보관

| 세대 |                     설명                    |
|:----:|:-------------------------------------------:|
|   0  |       빨리 사라질 것으로 예상되는 객체      |
|   1  |                                             |
|   2  | 오랫동안 살아남아 있을 것으로 예상되는 객체 |

### 세대를 나누는 방법
* 객체가 가비지 컬렉션을 겪은 횟수로 구분
   * 횟수 적음 : 메모리에서 빨리 사라진다고 예상
   * 횟수 많음 : 메모리에서 오랫동안 살아남는다고 예상

| 세대 |               세대에 포함된 객체 설명              |
|:----:|:--------------------------------------------------:|
|   0  |                   갓 생성된 객체                   |
|   1  |    0세대에서 2세대로 넘어가는 중간에 위치한 객체   |
|   2  | 여러번의 Garbage Collection을 겪어도 살아남은 객체 |

### 예시
1. 프로그램이 실행되면서 힙에 객체들이 할당
2. 할당된 객체들의 총 크기가 0세대 가비지 컬렉션 임계치에 도달하면 0세대에 대한 가비지 컬렉션을 수행
3. 살아남은 객체들은 1세대로 이동 ( 이때, 0세대는 비어지고 2세대도 비어있음 )
4. 새로 생성된 객체들은 0세대로 채워짐
5. 또 한번 0세대 객체들이 많아져 임계치에 도달하면 0세대에 대한 가비지 컬렉션을 수행
6. 살아남은 객체들은 1세대로 이동
7. 1세대 객체들이 많아져 임계치에 도달하면 1세대에 대한 가비지 컬렉션을 수행
8. 이땐, 가비지 컬렉터는 하위 세대에 대해서도 가비지 컬렉션을 수행하기에 0, 1세대 둘 다 가비지 컬렉션을 수행
9. 살아남은 0세대 객체들은 1세대로 1세대 객체들은 2세대로 이동
10. 2세대로 옮겨간 객체들은 더 이상 다른 곳으로 가지 않음
11. 2세대도 포화되어 가비지 컬렉션이 수행되면, 0, 1세대에 대해서도 수행

#### 힙의 각 세대의 가비지 컬렉션 빈도
* 2세대 < 1세대 0세대
* 그러므로, 2세대는 오래 살아남을 확률이 높고, 0세대는 오래 살아남을 확률이 적음
   * 왜? - 가비지 컬렉션 호출이 잦으면, 그만큼 메모리에서 사라질 확률이 높기 때문

**그래서 2세대에서 수행되어지는 가비지 컬렉션을 Full GC(Full Garbage Collection), 즉 전체 가비지 컬렉션이라 부름**

### ⭐⭐⭐⭐ Full GC의 단점(우리가 가비지 컬렉션을 이해해야 하는 이유) ⭐⭐⭐⭐
* 2세대 힙이 가득 차게 되면, CLR은 프로그램 실행을 잠시 멈추고 Full GC를 수행함으로써 여유 메모리를 확보하려 함
* CLR이 Full GC를 할 때 0세대 부터 2세대까지 메모리 전체에 대해 가비지 수집을 진행
   * 이때, 메모리가 크면 클수록 Full GC의 시간이 길어져 프로그램이 멈추는 시간도 그만큼 늘어나게 됨
